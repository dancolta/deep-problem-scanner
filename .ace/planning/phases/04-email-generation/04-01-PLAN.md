# Plan: AI Email Generation & CSV Processing

**Phase:** 4 - AI Email Generation
**Plan:** 1 of 1 in phase
**Status:** Ready

## Objective

Build the Gemini-powered email generation service with structured prompts enforcing 80-word body limit, and the CSV parser with lead processing pipeline for the full scan-to-email workflow.

## Tasks

### Task 1: Gemini Email Generation Service
**Zone:** ALPHA
**Files:**
- `src/services/email/email-generator.ts`

**Action:**
1. Create `src/services/email/email-generator.ts`:
   - `EmailGenerator` class
   - Uses `GoogleGenerativeAI` from `@google/generative-ai`
   - Constructor: initialize with `process.env.GEMINI_API_KEY`, use `gemini-1.5-flash` model (faster + cheaper for text generation)

   **Core method:**
   ```typescript
   async generateEmail(context: PromptContext): Promise<GeneratedEmail>
   ```
   - Accept PromptContext (from BETA's types) containing: company name, contact name, website URL, diagnostics summary, screenshot URL, annotation details
   - Build prompt using BETA's prompt template builder (import `buildEmailPrompt` from `./prompt-template`)
   - Call Gemini API:
     ```typescript
     const result = await model.generateContent(prompt);
     const text = result.response.text();
     ```
   - Parse JSON response expecting: `{ "subject": "...", "body": "..." }`
   - JSON parsing strategy:
     1. Try `JSON.parse(text)` directly
     2. If fails, extract JSON with regex: `/\{[\s\S]*?\}/`
     3. If still fails, retry the API call once with a stricter prompt
     4. If all fails, generate fallback email with template
   - Validate response:
     - Subject exists and is non-empty (max 80 chars)
     - Body exists and is non-empty
     - Body word count <= 80 (if over, truncate at last complete sentence under 80 words)
   - Return `GeneratedEmail` object

   **Batch method:**
   ```typescript
   async generateBatch(contexts: PromptContext[]): Promise<GeneratedEmail[]>
   ```
   - Process sequentially (avoid Gemini rate limits)
   - Small delay between calls (200ms)
   - Continue on individual failures (return fallback email)
   - Log progress

   **Fallback email generator:**
   ```typescript
   private generateFallback(context: PromptContext): GeneratedEmail
   ```
   - Template-based fallback if AI fails:
     - Subject: `Quick question about ${context.companyName}'s website`
     - Body: Brief template mentioning the scan found issues, with a CTA to discuss

**Verify:**
- [ ] Gemini API call structured correctly with prompt
- [ ] JSON parsing handles clean JSON, embedded JSON, and failures
- [ ] Word count validation enforces 80-word limit
- [ ] Fallback email generated on API failure
- [ ] Batch processing with sequential calls and delay
- [ ] TypeScript compiles without errors

**Done when:**
EmailGenerator can generate personalized subject + body emails from scan context via Gemini, with robust parsing, word count enforcement, and fallback handling.

---

### Task 2: Prompt Templates & Email Types
**Zone:** BETA
**Files:**
- `src/services/email/prompt-template.ts`
- `src/services/email/types.ts`

**Action:**
1. Create `src/services/email/types.ts`:
   ```typescript
   export interface PromptContext {
     companyName: string;
     contactName: string;
     websiteUrl: string;
     diagnosticsSummary: string;    // Human-readable summary of 5 diagnostic results
     screenshotUrl: string;         // Drive direct link for the annotated screenshot
     annotationLabels: string[];    // e.g. ["No CTA Button", "Slow Load", "Missing H1"]
     problemCount: number;
     worstProblem: string;          // The most critical finding
   }

   export interface GeneratedEmail {
     subject: string;
     body: string;
     wordCount: number;
     generatedAt: string;  // ISO timestamp
     wasAIGenerated: boolean;  // false if fallback was used
   }

   export interface EmailGenerationOptions {
     maxBodyWords: number;      // default 80
     maxSubjectChars: number;   // default 80
     tone: 'professional' | 'casual' | 'friendly';
     includeScreenshotMention: boolean;
   }

   export const DEFAULT_EMAIL_OPTIONS: EmailGenerationOptions = {
     maxBodyWords: 80,
     maxSubjectChars: 80,
     tone: 'professional',
     includeScreenshotMention: true,
   };
   ```

2. Create `src/services/email/prompt-template.ts`:
   ```typescript
   export function buildEmailPrompt(context: PromptContext, options?: Partial<EmailGenerationOptions>): string
   ```

   The prompt should instruct Gemini to:
   - Write a cold outreach email to `{contactName}` at `{companyName}`
   - Reference their website `{websiteUrl}` and specific problems found
   - Mention the annotated screenshot is attached/included showing the issues
   - Keep body STRICTLY under 80 words
   - Use professional but approachable tone
   - Include a soft CTA (e.g., "Would you be open to a quick chat about this?")
   - Do NOT use generic sales language or buzzwords
   - Personalize based on the ACTUAL problems found, not generic copy
   - Reference specific findings: `{annotationLabels}` and `{worstProblem}`

   Full prompt template:
   ```
   You are writing a personalized cold outreach email. Generate a subject line and email body.

   RECIPIENT:
   - Name: {contactName}
   - Company: {companyName}
   - Website: {websiteUrl}

   FINDINGS FROM WEBSITE SCAN:
   - Problems found: {problemCount}
   - Key issues: {annotationLabels joined}
   - Most critical: {worstProblem}
   - Full diagnostics: {diagnosticsSummary}

   RULES:
   1. Subject line: max {maxSubjectChars} characters, specific to their website, NOT generic
   2. Email body: STRICTLY {maxBodyWords} words or fewer. Count carefully.
   3. Tone: {tone}, not salesy
   4. Reference the annotated screenshot that shows the problems visually
   5. Mention 1-2 specific problems from the scan (use the actual findings above)
   6. End with a soft, non-pushy call to action
   7. Do NOT use: "I hope this email finds you well", "I noticed", "I came across", or other overused openers
   8. Start with something direct and specific to their website

   FORMAT: Respond ONLY with valid JSON:
   {
     "subject": "your subject line here",
     "body": "your email body here"
   }
   ```

   **Helper functions:**
   ```typescript
   export function buildDiagnosticsSummary(diagnostics: DiagnosticResult[]): string
   ```
   - Convert DiagnosticResult array to human-readable summary
   - Format: "Speed: Pass (85/100) | Mobile: Warning (60/100) | CTA: Fail (20/100) | ..."

   ```typescript
   export function countWords(text: string): number
   ```
   - Split on whitespace, filter empty, return count

   ```typescript
   export function truncateToWordLimit(text: string, maxWords: number): string
   ```
   - If under limit, return as-is
   - Otherwise, find the last sentence boundary (. ! ?) before the word limit
   - If no sentence boundary found, cut at word limit and add "..."

**Verify:**
- [ ] Types are comprehensive and well-documented
- [ ] Prompt template produces clear, specific instructions
- [ ] DiagnosticsSummary formats results readably
- [ ] Word counting is accurate
- [ ] Truncation preserves complete sentences
- [ ] TypeScript compiles without errors

**Done when:**
Prompt template generates specific, personalized prompts from scan context, types cover the full email generation flow, and helper utilities handle word counting and truncation.

---

### Task 3: CSV Parser & Lead Processing Pipeline
**Zone:** GAMMA
**Files:**
- `src/services/csv/csv-parser.ts`
- `src/services/csv/lead-pipeline.ts`

**Action:**
1. Create `src/services/csv/csv-parser.ts`:
   ```typescript
   export class CsvParser {
     parse(csvContent: string): ParseResult
     validateHeaders(headers: string[]): ValidationResult
   }
   ```

   **parse(csvContent):**
   - Split by newlines, handle both \n and \r\n
   - First line is headers
   - Parse each row, handling:
     - Quoted fields (commas inside quotes)
     - Escaped quotes (double-quote inside quoted field)
     - Empty fields
     - Trailing commas
   - Map each row to a `Lead` object using header names
   - Return `ParseResult`: { leads: Lead[], headers: string[], errors: string[] }

   **validateHeaders(headers):**
   - Required columns: 'company_name', 'website_url', 'contact_name', 'contact_email'
   - Case-insensitive matching (normalize to lowercase, trim whitespace)
   - Also accept common variants: 'company' for 'company_name', 'website'/'url' for 'website_url', 'name' for 'contact_name', 'email' for 'contact_email'
   - Return `ValidationResult`: { valid: boolean, missingColumns: string[], columnMap: Record<string, string> }
   - columnMap maps actual CSV header names to our standard field names

   **Additional validation on parsed leads:**
   - `validateLeads(leads: Lead[]): { valid: Lead[], invalid: { lead: Lead, reason: string }[] }`
   - Check: website_url looks like a URL (starts with http or has a dot)
   - Check: contact_email looks like an email (has @ and .)
   - Check: company_name is non-empty
   - Return separate valid and invalid arrays

   **Duplicate detection within CSV:**
   - `filterDuplicateEmails(leads: Lead[]): { unique: Lead[], duplicates: Lead[] }`
   - Remove leads with duplicate contact_email (keep first occurrence)

2. Create `src/services/csv/lead-pipeline.ts`:
   ```typescript
   export class LeadPipeline {
     constructor(private csvParser: CsvParser, private sheetsService?: SheetsService)
   ```

   **Core method:**
   ```typescript
   async processUpload(
     csvContent: string,
     spreadsheetId?: string,
     rowRange?: { start: number, end: number }
   ): Promise<PipelineResult>
   ```

   Pipeline steps:
   1. Parse CSV → get all leads
   2. Validate headers → abort with clear error if missing required columns
   3. Validate leads → separate valid from invalid
   4. Filter duplicate emails within CSV
   5. If spreadsheetId provided and sheetsService available:
      - Check Sheets for already-scanned URLs via `sheetsService.checkDuplicates()`
      - Filter out already-scanned leads
   6. Apply row range selection if provided (0-based, slice the array)
   7. Return `PipelineResult`:
      ```typescript
      {
        leads: Lead[],              // Ready to scan
        totalParsed: number,
        invalidLeads: { lead: Lead, reason: string }[],
        duplicateEmails: Lead[],
        alreadyScanned: Lead[],
        skippedByRange: number,
      }
      ```

   **Type definitions (in same file):**
   ```typescript
   export interface ParseResult {
     leads: Lead[];
     headers: string[];
     errors: string[];
   }

   export interface ValidationResult {
     valid: boolean;
     missingColumns: string[];
     columnMap: Record<string, string>;
   }

   export interface PipelineResult {
     leads: Lead[];
     totalParsed: number;
     invalidLeads: { lead: Lead; reason: string }[];
     duplicateEmails: Lead[];
     alreadyScanned: Lead[];
     skippedByRange: number;
   }
   ```

**Verify:**
- [ ] CSV parser handles quoted fields, escaped quotes, empty fields
- [ ] Header validation accepts common column name variants
- [ ] Lead validation checks URL and email format
- [ ] Duplicate email detection works within CSV
- [ ] Pipeline chains all steps correctly
- [ ] Row range selection works (0-based slicing)
- [ ] TypeScript compiles without errors

**Done when:**
CSV parser handles real-world CSV files robustly, lead pipeline orchestrates parsing → validation → dedup → sheets check → range selection and returns a clean set of leads ready to scan.

---

## Checkpoints

None - fully autonomous execution.

## Success Criteria

- [ ] All tasks completed
- [ ] All verifications pass
- [ ] Gemini generates personalized emails with subject + body
- [ ] 80-word body limit enforced
- [ ] CSV parser handles edge cases (quotes, commas, variants)
- [ ] Lead pipeline filters duplicates and already-scanned URLs
- [ ] TypeScript compiles without errors
