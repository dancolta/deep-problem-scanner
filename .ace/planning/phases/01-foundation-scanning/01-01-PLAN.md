# Plan: Project Scaffolding & Core Scanning Engine

**Phase:** 1 - Project Foundation & Core Scanning Engine
**Plan:** 1 of 1 in phase
**Status:** Ready

## Objective

Set up the Electron + React + TypeScript project structure with all dependencies, build the headless browser scanning service with 5 diagnostic checks, and establish the renderer shell with IPC communication bridge.

## Tasks

### Task 1: Project Scaffolding & Electron Main Process
**Zone:** ALPHA
**Files:**
- `package.json`
- `tsconfig.json`
- `tsconfig.main.json`
- `tsconfig.renderer.json`
- `electron/main.ts`
- `electron/preload.ts`
- `.env.example`
- `.gitignore`
- `electron-builder.config.js`

**Action:**
1. Initialize `package.json` with project metadata and scripts:
   - Dependencies: electron, react, react-dom, react-router-dom, puppeteer, puppeteer-extra, puppeteer-extra-plugin-stealth, sharp, @google-cloud/local-auth, googleapis, @google/generative-ai
   - Dev dependencies: typescript, @types/react, @types/react-dom, electron-builder, webpack, webpack-cli, ts-loader, html-webpack-plugin, css-loader, style-loader
   - Scripts: `dev`, `build`, `start`, `package`
2. Create TypeScript configs:
   - `tsconfig.json` - base config with strict mode, ES2022 target
   - `tsconfig.main.json` - extends base, targets electron main process (node module resolution)
   - `tsconfig.renderer.json` - extends base, targets renderer (JSX, DOM lib)
3. Create `electron/main.ts`:
   - BrowserWindow creation (1200x800 default)
   - Load renderer (dev: webpack-dev-server, prod: built files)
   - IPC handler registration
   - App lifecycle (ready, window-all-closed, activate)
4. Create `electron/preload.ts`:
   - Context bridge exposing IPC invoke/on methods
   - Typed API surface for renderer
5. Update `.env.example` with: GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GEMINI_API_KEY
6. Update `.gitignore` for node_modules, dist, build, .env, *.pem
7. Create `electron-builder.config.js` for macOS/Windows/Linux packaging

**Verify:**
- [ ] `npm install` completes without errors
- [ ] TypeScript configs are valid (`npx tsc --noEmit` on main process files)
- [ ] Electron main process file has proper BrowserWindow setup
- [ ] Preload script exposes typed IPC bridge

**Done when:**
Project runs `npm install` successfully, TypeScript compiles without errors, and `electron/main.ts` creates a BrowserWindow with preload script.

---

### Task 2: Scanner Service & 5 Diagnostic Checks
**Zone:** BETA
**Files:**
- `src/services/scanner/scanner-service.ts`
- `src/services/scanner/diagnostics.ts`
- `src/services/scanner/stealth.ts`
- `src/services/scanner/types.ts`
- `src/utils/timeout.ts`
- `src/utils/logger.ts`

**Action:**
1. Create `src/services/scanner/stealth.ts`:
   - Configure puppeteer-extra with stealth plugin
   - Export stealth-enabled browser launch function
   - Bot detection: check page content for 'Cloudflare', 'CAPTCHA', 'Access Denied' keywords
   - Return detection result alongside page content
2. Create `src/services/scanner/scanner-service.ts`:
   - `ScannerService` class with configurable concurrency (1-5)
   - `scanHomepage(url: string)`: navigate to URL, wait for load, capture screenshot at 1440x900
   - `scanBatch(urls: string[], concurrency: number)`: process URLs with configurable parallelism using a semaphore/pool pattern
   - 30-second timeout per site (use timeout utility)
   - On failure: return ScanResult with status='FAILED' and error message
   - On bot detection: return ScanResult with status='BLOCKED' and detection type
   - Screenshot returned as Buffer (PNG format)
3. Create `src/services/scanner/diagnostics.ts`:
   - `runDiagnostics(page: Page, url: string): DiagnosticResult[]`
   - **Speed check**: Measure page load time via Performance API (Navigation Timing)
   - **Mobile-friendliness**: Check for viewport meta tag, responsive indicators
   - **CTA analysis**: Scan for buttons/links with action words (buy, sign up, contact, get started, etc.)
   - **SEO basics**: Check title tag, meta description, h1 presence, alt text on images
   - **Broken links**: Collect all links on page, check HTTP status (HEAD requests, limit to 20 links, 5s timeout each)
   - Each diagnostic returns: { name, status: 'pass'|'warning'|'fail', details, score }
4. Create `src/services/scanner/types.ts`:
   - `ScanResult` interface: url, screenshot (Buffer), diagnostics, status, error, timestamp
   - `DiagnosticResult` interface: name, status, details, score
   - `ScanStatus` type: 'SUCCESS' | 'FAILED' | 'BLOCKED' | 'TIMEOUT'
5. Create `src/utils/timeout.ts`:
   - `withTimeout<T>(promise: Promise<T>, ms: number, errorMsg?: string): Promise<T>`
   - Rejects with TimeoutError if promise doesn't resolve within ms
6. Create `src/utils/logger.ts`:
   - Simple logger with levels: info, warn, error, debug
   - Timestamps + context prefix

**Verify:**
- [ ] Scanner service can be instantiated with concurrency config
- [ ] All 5 diagnostic functions exist and return DiagnosticResult
- [ ] Timeout utility properly races promises
- [ ] Bot detection checks for Cloudflare/CAPTCHA keywords
- [ ] TypeScript compiles without errors

**Done when:**
ScannerService class can scan a URL with Puppeteer stealth, capture a 1440x900 screenshot, run 5 diagnostics, handle timeouts (30s), detect bot protection, and process batches with configurable concurrency.

---

### Task 3: React Renderer Shell, Shared Types & IPC Bridge
**Zone:** GAMMA
**Files:**
- `src/renderer/index.html`
- `src/renderer/index.tsx`
- `src/renderer/App.tsx`
- `src/renderer/global.d.ts`
- `src/shared/types.ts`
- `src/shared/ipc-channels.ts`
- `src/renderer/hooks/useIpc.ts`
- `webpack.config.js`

**Action:**
1. Create `src/shared/types.ts`:
   - `Lead` interface: { company_name, website_url, contact_name, contact_email, [key: string]: string }
   - `ScanResult` interface (re-export or shared version without Buffer - use base64 string for renderer)
   - `DiagnosticResult` interface
   - `ScanStatus` type
   - `ScanProgress` interface: { total, completed, failed, current_url }
   - `AppSettings` interface: { googleSheetUrl, concurrency, sendInterval }
   - `EmailDraft` interface: { to, subject, body, screenshotUrl, leadData }
2. Create `src/shared/ipc-channels.ts`:
   - Constants for all IPC channels: SCAN_START, SCAN_PROGRESS, SCAN_COMPLETE, SCAN_CANCEL, SETTINGS_GET, SETTINGS_SET, etc.
3. Create `src/renderer/index.html`:
   - Basic HTML shell with div#root
   - CSP meta tag for Electron security
4. Create `src/renderer/index.tsx`:
   - React 18 createRoot entry point
   - Render App component
5. Create `src/renderer/App.tsx`:
   - React Router with 5 route placeholders: /setup, /upload, /scan, /drafts, /schedule
   - Simple navigation layout
   - Each route renders a placeholder component with the screen name
6. Create `src/renderer/global.d.ts`:
   - Type declarations for window.electronAPI (matches preload bridge)
7. Create `src/renderer/hooks/useIpc.ts`:
   - `useIpc<T>(channel: string)` - hook for invoke/response pattern
   - `useIpcListener(channel: string, callback)` - hook for event listening (scan progress)
8. Create `webpack.config.js`:
   - Renderer webpack config: TypeScript + React + CSS
   - Dev server config for hot reload
   - Production build config

**Verify:**
- [ ] Shared types cover Lead, ScanResult, DiagnosticResult, ScanProgress
- [ ] IPC channels are defined as constants
- [ ] React app renders with router and 5 route placeholders
- [ ] Webpack config handles TypeScript + React compilation
- [ ] TypeScript compiles without errors

**Done when:**
React renderer shell loads in Electron with React Router, 5 placeholder screens exist, IPC hooks are available for communication with main process, shared types are defined for all core data structures.

---

## Checkpoints

None - fully autonomous execution.

## Success Criteria

- [ ] All tasks completed
- [ ] All verifications pass
- [ ] `npm install` succeeds
- [ ] TypeScript compiles without errors (`npx tsc --noEmit`)
- [ ] Electron app launches and shows React renderer with placeholder screens
