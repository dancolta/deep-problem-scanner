# Plan: Scheduler Service & Gmail Draft Creation

**Phase:** 6 - Email Scheduler & Integration Testing
**Plan:** 1 of 2 in phase
**Status:** Ready

## Objective

Build the in-memory email scheduler with timezone-aware interval sending, Gmail API integration for creating drafts with embedded screenshots, and wire both into the existing IPC placeholder handlers.

## Tasks

### Task 1: Gmail Draft Service
**Zone:** ALPHA
**Files:**
- `src/services/google/gmail.ts`

**Action:**
1. Create `src/services/google/gmail.ts`:
   - `GmailService` class
   - Constructor: takes `OAuth2Client` (same pattern as SheetsService/DriveService)
   - Uses `google.gmail({ version: 'v1', auth })` from `googleapis`

   **Core methods:**

   a) `createDraft(draft: EmailDraft): Promise<{ draftId: string; threadId: string }>`
   - Build MIME message with:
     - To: draft.to (contact email)
     - Subject: draft.subject
     - Content-Type: multipart/mixed (HTML body + image attachment)
     - HTML body: convert plain text body to HTML, embed screenshot as inline image using CID
     - Attach annotated screenshot from Drive URL (fetch the image bytes, attach as base64)
   - Use `gmail.users.drafts.create({ userId: 'me', requestBody: { message: { raw: base64EncodedMime } } })`
   - Return draft ID and thread ID

   b) `sendDraft(draftId: string): Promise<{ messageId: string }>`
   - Use `gmail.users.drafts.send({ userId: 'me', requestBody: { id: draftId } })`
   - Return message ID

   c) `listDrafts(): Promise<{ id: string; subject: string }[]>`
   - List existing drafts for status checking

   **MIME building helper:**
   - `buildMimeMessage(to, subject, htmlBody, screenshotBuffer?, screenshotFilename?)`: string
   - Use multipart/mixed boundary
   - Text part as text/html
   - Image part as image/png with Content-ID for inline embedding
   - Return raw base64url-encoded string

**Verify:**
- [ ] MIME message correctly structured with HTML body
- [ ] Screenshot embedded as inline attachment
- [ ] Draft created via Gmail API
- [ ] Draft can be sent
- [ ] TypeScript compiles without errors

**Done when:**
GmailService creates Gmail drafts with HTML body and inline screenshot attachment.

---

### Task 2: Email Scheduler Service
**Zone:** BETA
**Files:**
- `src/services/scheduler/email-scheduler.ts`
- `src/services/scheduler/types.ts`

**Action:**
1. Create `src/services/scheduler/types.ts`:
   ```typescript
   export interface ScheduledEmail {
     id: string;
     draft: EmailDraft;
     scheduledTime: string; // ISO
     status: 'pending' | 'sending' | 'sent' | 'failed';
     draftId?: string; // Gmail draft ID
     messageId?: string; // Gmail message ID after send
     error?: string;
     attempts: number;
   }

   export interface SchedulerConfig {
     intervalMinutes: number; // default 15
     timezone: string;
     maxRetries: number; // default 3
   }

   export interface SchedulerStatus {
     running: boolean;
     queueSize: number;
     nextSendTime: string | null;
     sent: number;
     failed: number;
   }

   export type SchedulerEvent = {
     type: 'send_success' | 'send_failed' | 'started' | 'stopped' | 'queue_updated';
     timestamp: string;
     detail: string;
     emailId?: string;
   };
   ```

2. Create `src/services/scheduler/email-scheduler.ts`:
   - `EmailScheduler` class
   - Constructor: takes `GmailService`, `SheetsService`, `SchedulerConfig`
   - Maintains in-memory queue: `ScheduledEmail[]`
   - Event callback: `onEvent: (event: SchedulerEvent) => void`

   **Core methods:**

   a) `start(): void`
   - Set running = true
   - Start interval timer (setInterval at config.intervalMinutes * 60 * 1000)
   - Each tick: process next pending email in queue
   - Emit 'started' event

   b) `stop(): void`
   - Set running = false
   - Clear interval timer
   - Emit 'stopped' event

   c) `addToQueue(drafts: EmailDraft[]): void`
   - Calculate scheduled times: stagger from now, each `intervalMinutes` apart
   - Create ScheduledEmail entries with status 'pending'
   - Sort queue by scheduledTime
   - Emit 'queue_updated' event

   d) `getStatus(): SchedulerStatus`
   - Return current state: running, queue size, next send time, sent/failed counts

   e) `private async processNext(): Promise<void>`
   - Find first pending email where scheduledTime <= now
   - If none, skip
   - Set status to 'sending'
   - Try: create Gmail draft → send draft → set status to 'sent' → update Sheet row
   - Catch: increment attempts, if < maxRetries set back to 'pending' with delay, else 'failed'
   - Emit send_success or send_failed event

   f) `getQueue(): ScheduledEmail[]`
   - Return current queue for UI display

   **Crash recovery:**
   - On start, check Sheet for rows with email_status='scheduled' that weren't sent
   - Re-queue those as pending

**Verify:**
- [ ] Interval-based sending works
- [ ] Staggered scheduling calculates correct times
- [ ] Retry logic on failure (max 3 attempts)
- [ ] Events emitted for UI updates
- [ ] Start/stop controls work
- [ ] TypeScript compiles without errors

**Done when:**
EmailScheduler manages an in-memory queue, sends emails at configured intervals via Gmail, handles retries, and emits events for real-time UI updates.

---

### Task 3: Wire Gmail & Scheduler into IPC Handlers
**Zone:** GAMMA
**Files:**
- `electron/ipc-handlers.ts` (modify — replace Gmail/Scheduler placeholders)
- `electron/service-registry.ts` (modify — add GmailService and EmailScheduler)

**Action:**
1. Modify `electron/service-registry.ts`:
   - Add `GmailService` import and lazy getter: `getAuthenticatedGmail(): Promise<GmailService>`
   - Add `EmailScheduler` instance (initialized with GmailService, SheetsService, config from settings)
   - Add `getScheduler(): Promise<EmailScheduler>` — creates on first call

2. Modify `electron/ipc-handlers.ts`:
   - Replace Gmail placeholder handlers:
     - `GMAIL_CREATE_DRAFT`: Get GmailService, call `createDraft(draft)`, return result
     - `GMAIL_SEND`: Get GmailService, call `sendDraft(draftId)`, return result

   - Replace Scheduler placeholder handlers:
     - `SCHEDULER_START`: Get scheduler, load approved emails from Sheet, add to queue, start scheduler. Set `onEvent` callback to send `SCHEDULER_PROGRESS` to renderer via `webContents.send()`
     - `SCHEDULER_STOP`: Get scheduler, call stop()
     - `SCHEDULER_STATUS`: Get scheduler, return getStatus()
     - (SCHEDULER_PROGRESS is sent from main→renderer, not invoked)

**Verify:**
- [ ] GmailService accessible from service registry after auth
- [ ] EmailScheduler created with correct config
- [ ] IPC handlers replace all placeholders
- [ ] SCHEDULER_START loads approved drafts and starts sending
- [ ] SCHEDULER_PROGRESS events forwarded to renderer
- [ ] TypeScript compiles without errors

**Done when:**
All Gmail and Scheduler IPC handlers are fully functional, wired through the service registry.

---

## Checkpoints

None - fully autonomous execution.

## Success Criteria

- [ ] All tasks completed
- [ ] Gmail drafts created with inline screenshots
- [ ] Scheduler sends at configured intervals
- [ ] IPC handlers fully replace all Phase 6 placeholders
- [ ] TypeScript compiles without errors
- [ ] Webpack builds successfully
